using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace NetCorePal.Extensions.CodeAnalysis.SourceGenerators;

[Generator]
public class EndpointMetadataGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var methodDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => node is MethodDeclarationSyntax,
                transform: (ctx, _) => ctx.Node as MethodDeclarationSyntax)
            .Where(m => m != null);

        var compilationAndMethods = context.CompilationProvider.Combine(methodDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndMethods, (spc, source) =>
        {
            var (compilation, methodNodes) = source;
            var endpointMetas = new List<(string EndpointType, string MethodName, List<string> CommandTypes)>();

            foreach (var method in methodNodes)
            {
                if (method == null) continue;
                var semanticModel = compilation.GetSemanticModel(method.SyntaxTree);
                if (semanticModel == null) continue;
                var methodSymbol = semanticModel.GetDeclaredSymbol(method) as IMethodSymbol;
                if (methodSymbol == null) continue;
                // 忽略构造函数
                if (methodSymbol.MethodKind == MethodKind.Constructor) continue;
                // 忽略Configure方法
                if (methodSymbol.Name == "Configure") continue;
                var containingType = methodSymbol.ContainingType;
                if (containingType == null || containingType.DeclaredAccessibility != Accessibility.Public) continue;
                // 只要继承 Endpoint<TRequest, TResponse> 或 EndpointWithoutRequest<TResponse> 基类（支持泛型），都认为是 Endpoint
                bool isEndpoint = false;
                foreach (var baseType in containingType.AllInterfaces.Concat(new[] { containingType.BaseType }))
                {
                    if (baseType == null) continue;
                    var baseName = baseType.OriginalDefinition?.ToDisplayString() ?? baseType.ToDisplayString();
                    if (baseName == "FastEndpoints.Endpoint" ||
                        baseName.StartsWith("FastEndpoints.Endpoint<") ||
                        baseName == "FastEndpoints.EndpointWithoutRequest" ||
                        baseName.StartsWith("FastEndpoints.EndpointWithoutRequest<"))
                    {
                        isEndpoint = true;
                        break;
                    }
                }
                if (!isEndpoint) continue;

                // 查找参数和方法体内所有命令类型
                var commandTypes = new HashSet<string>();
                // 1. 参数中的命令类型
                foreach (var param in methodSymbol.Parameters)
                {
                    if (param.Type is INamedTypeSymbol namedType && GeneratorExtensions.IsCommand(namedType))
                    {
                        commandTypes.Add(namedType.ToDisplayString());
                    }
                }
                // 2. 方法体内的命令发送调用
                if (method.Body != null)
                {
                    foreach (var invocation in method.Body.DescendantNodes().OfType<InvocationExpressionSyntax>())
                    {
                        var invokedSymbol = semanticModel.GetSymbolInfo(invocation).Symbol as IMethodSymbol;
                        if (invokedSymbol == null) continue;
                        var name = invokedSymbol.Name.ToLower();
                        if (name.Contains("send") || name.Contains("publish") || name.Contains("execute") || name.Contains("dispatch"))
                        {
                            // 尝试获取命令类型参数
                            if (invocation.ArgumentList.Arguments.Count > 0)
                            {
                                var arg = invocation.ArgumentList.Arguments[0];
                                var argType = semanticModel.GetTypeInfo(arg.Expression).Type;
                                if (argType is INamedTypeSymbol namedType2 && GeneratorExtensions.IsCommand(namedType2))
                                {
                                    commandTypes.Add(namedType2.ToDisplayString());
                                }
                            }
                        }
                    }
                }
                // 无论是否发出命令，都记录Endpoint元数据
                endpointMetas.Add((containingType.ToDisplayString(), methodSymbol.Name, commandTypes.ToList()));
            }

            if (endpointMetas.Count > 0)
            {
                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated/>\nusing System;\nusing NetCorePal.Extensions.CodeAnalysis.Attributes;");
                foreach (var (endpointType, methodName, commandTypes) in endpointMetas)
                {
                    string commandsLiteral;
                    if (commandTypes.Count == 0)
                    {
                        commandsLiteral = string.Empty;
                    }
                    else
                    {
                        commandsLiteral = string.Join(", ", commandTypes.Select(c => $"\"{c}\""));
                    }
                    sb.AppendLine(commandTypes.Count == 0
                        ? $"[assembly: EndpointMetadataAttribute(\"{endpointType}\", \"{methodName}\")]\n"
                        : $"[assembly: EndpointMetadataAttribute(\"{endpointType}\", \"{methodName}\", {commandsLiteral})]\n");
                }
                spc.AddSource("EndpointMetadata.g.cs", sb.ToString());
            }
        });
    }
}
