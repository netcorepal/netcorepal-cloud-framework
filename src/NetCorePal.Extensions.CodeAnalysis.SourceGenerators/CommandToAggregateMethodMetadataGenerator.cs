using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

[Generator]
public class CommandToAggregateMethodMetadataGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => node is ClassDeclarationSyntax,
                transform: (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
            .Where(c => c != null);

        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses, (spc, source) =>
        {
            var (compilation, classes) = source;
            var relations = new List<(string CommandType, string AggregateType, string MethodName, string[] EventTypes)>();

            foreach (var classDecl in classes)
            {
                var semanticModel = compilation.GetSemanticModel(classDecl.SyntaxTree);
                var symbol = semanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
                if (symbol == null) continue;
                var handlerInterface = symbol.AllInterfaces.FirstOrDefault(i =>
                    i.IsGenericType && (i.Name == "ICommandHandler" || i.Name == "IRequestHandler"));
                if (handlerInterface == null) continue;
                var commandType = handlerInterface.TypeArguments[0].ToDisplayString();

                foreach (var method in classDecl.Members.OfType<MethodDeclarationSyntax>())
                {
                    if (!method.Identifier.Text.StartsWith("Handle")) continue;
                    var invocations = method.DescendantNodes().OfType<InvocationExpressionSyntax>();
                    foreach (var invocation in invocations)
                    {
                        var invokedSymbol = semanticModel.GetSymbolInfo(invocation).Symbol as IMethodSymbol;
                        if (invokedSymbol == null) continue;
                        var aggType = invokedSymbol.ContainingType;
                        if (aggType.AllInterfaces.Any(i => i.Name == "IAggregateRoot"))
                        {
                            // 这里假设每个命令只对应一个事件，后续如需支持多个事件可扩展
                            var eventTypes = new List<string>();
                            // 可根据业务逻辑推断事件类型，这里暂用方法名作为事件类型
                            eventTypes.Add(invokedSymbol.Name + "DomainEvent");
                            relations.Add((commandType, aggType.ToDisplayString(), invokedSymbol.Name, eventTypes.ToArray()));
                        }
                    }
                }
            }

            if (relations.Count > 0)
            {
                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated/>\nusing System;\nusing NetCorePal.Extensions.CodeAnalysis.Attributes;");
                foreach (var rel in relations)
                {
                    var events = string.Join(", ", rel.EventTypes.Select(e => $"\"{e}\""));
                    sb.AppendLine($"[assembly: CommandToAggregateMethodMetadataAttribute(\"{rel.CommandType}\", \"{rel.AggregateType}\", \"{rel.MethodName}\", {events})]\n");
                }
                spc.AddSource("CommandToAggregateMethodMetadata.g.cs", sb.ToString());
            }
        });
    }
} 