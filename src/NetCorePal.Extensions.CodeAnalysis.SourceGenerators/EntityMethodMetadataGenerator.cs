using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace NetCorePal.Extensions.CodeAnalysis.SourceGenerators;

[Generator]
public class EntityMethodMetadataGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var methodDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => node is MethodDeclarationSyntax,
                transform: (ctx, _) => ctx.Node as MethodDeclarationSyntax)
            .Where(m => m != null);

        var compilationAndMethods = context.CompilationProvider.Combine(methodDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndMethods, (spc, source) =>
        {
            var (compilation, methodNodes) = source;
            var metas = new List<(string EntityType, string MethodName, List<string> EventTypes, List<string> CalledEntityMethods)>();

            foreach (var method in methodNodes)
            {
                if (method == null) continue;
                var semanticModel = compilation.GetSemanticModel(method.SyntaxTree);
                if (semanticModel == null) continue;
                var methodSymbol = semanticModel.GetDeclaredSymbol(method) as IMethodSymbol;
                if (methodSymbol == null) continue;
                var containingType = methodSymbol.ContainingType;
                if (containingType == null || containingType.DeclaredAccessibility != Accessibility.Public) continue;
                // 只为实体类型生成元数据
                if (!containingType.IsEntity()) continue;

                // 查找方法体内所有 new 表达式，判断是否为领域事件类型
                var eventTypes = new HashSet<string>();
                var calledEntityMethods = new HashSet<string>();
                if (method.Body != null)
                {
                    foreach (var objCreation in method.Body.DescendantNodes().OfType<ObjectCreationExpressionSyntax>())
                    {
                        var typeInfo = semanticModel.GetTypeInfo(objCreation).Type;
                        if (typeInfo is INamedTypeSymbol namedType && namedType.AllInterfaces.Any(i => i.Name == "IDomainEvent"))
                        {
                            eventTypes.Add(namedType.ToDisplayString());
                        }
                    }

                    // 查找方法体内所有方法调用，判断是否为其它实体方法
                    foreach (var invocation in method.Body.DescendantNodes().OfType<InvocationExpressionSyntax>())
                    {
                        var invokedSymbol = semanticModel.GetSymbolInfo(invocation).Symbol as IMethodSymbol;
                        if (invokedSymbol == null) continue;
                        var targetType = invokedSymbol.ContainingType;
                        if (targetType != null && targetType.IsEntity())
                        {
                            calledEntityMethods.Add($"{targetType.ToDisplayString()}.{invokedSymbol.Name}");
                        }
                    }
                }
                if (eventTypes.Count > 0 || calledEntityMethods.Count > 0)
                {
                    metas.Add((containingType.ToDisplayString(), methodSymbol.Name, eventTypes.ToList(), calledEntityMethods.ToList()));
                }
            }

            if (metas.Count > 0)
            {
                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated/>\nusing System;\nusing NetCorePal.Extensions.CodeAnalysis.Attributes;");
                foreach (var (entityType, methodName, eventTypes, calledEntityMethods) in metas)
                {
                    var eventsLiteral = string.Join(", ", eventTypes.Select(e => $"\"{e}\""));
                    var calledMethodsLiteral = string.Join(", ", calledEntityMethods.Select(m => $"\"{m}\""));
                    sb.AppendLine($"[assembly: EntityMethodMetadataAttribute(\"{entityType}\", \"{methodName}\", new string[] {{ {eventsLiteral} }}, new string[] {{ {calledMethodsLiteral} }})]\n");
                }
                spc.AddSource("EntityMethodMetadata.g.cs", sb.ToString());
            }
        });
    }
}
