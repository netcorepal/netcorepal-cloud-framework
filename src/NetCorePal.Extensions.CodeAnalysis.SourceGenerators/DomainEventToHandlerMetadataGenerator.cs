using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace NetCorePal.Extensions.CodeAnalysis;
using System;

[Generator]
public class DomainEventToHandlerMetadataGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var typeDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => node is ClassDeclarationSyntax || node is RecordDeclarationSyntax,
                transform: (ctx, _) => ctx.Node)
            .Where(n => n is ClassDeclarationSyntax || n is RecordDeclarationSyntax);

        var compilationAndTypes = context.CompilationProvider.Combine(typeDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndTypes, (spc, source) =>
        {
            var (compilation, typeNodes) = ((Compilation, System.Collections.Immutable.ImmutableArray<SyntaxNode>))source;
            var relations = new List<(string DomainEventType, string[] HandlerTypes)>();
            var eventToHandlers = new Dictionary<string, HashSet<string>>();
            var allDomainEvents = new HashSet<string>();

            // 收集所有领域事件类型
            foreach (var typeDecl in typeNodes)
            {
                var semanticModel = compilation.GetSemanticModel(typeDecl.SyntaxTree);
                var symbol = semanticModel.GetDeclaredSymbol(typeDecl) as INamedTypeSymbol;
                if (symbol == null) continue;
                // 领域事件类型
                if (symbol.AllInterfaces.Any(i => i.Name == "IDomainEvent"))
                {
                    allDomainEvents.Add(symbol.ToDisplayString());
                }
            }

            // 收集所有领域事件处理器
            foreach (var typeDecl in typeNodes)
            {
                var semanticModel = compilation.GetSemanticModel(typeDecl.SyntaxTree);
                var symbol = semanticModel.GetDeclaredSymbol(typeDecl) as INamedTypeSymbol;
                if (symbol == null) continue;
                var handlerInterface = symbol.AllInterfaces.FirstOrDefault(i =>
                    i.IsGenericType && i.Name == "IDomainEventHandler");
                if (handlerInterface == null) continue;
                var eventType = handlerInterface.TypeArguments[0].ToDisplayString();
                var handlerType = symbol.ToDisplayString();

                if (!eventToHandlers.TryGetValue(eventType, out var handlers))
                {
                    handlers = new HashSet<string>();
                    eventToHandlers[eventType] = handlers;
                }
                handlers.Add(handlerType);
            }

            // 合并所有领域事件，确保无处理器的事件也被记录
            foreach (var evt in allDomainEvents)
            {
                var handlers = eventToHandlers.TryGetValue(evt, out var hs) ? hs.ToArray() : System.Array.Empty<string>();
                relations.Add((evt, handlers));
            }

            if (relations.Count > 0)
            {
                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated/>\nusing System;\nusing NetCorePal.Extensions.CodeAnalysis.Attributes;");
                foreach (var rel in relations)
                {
                    var handlers = string.Join(", ", rel.HandlerTypes.Select(h => $"\"{h}\""));
                    sb.AppendLine($"[assembly: DomainEventToHandlerMetadataAttribute(\"{rel.DomainEventType}\", {handlers})]\n");
                }
                spc.AddSource("DomainEventToHandlerMetadata.g.cs", sb.ToString());
            }
        });
    }
}
