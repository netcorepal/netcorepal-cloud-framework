using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace NetCorePal.Extensions.CodeAnalysis.SourceGenerators;

[Generator]
public class IntegrationEventHandlerMetadataGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var typeDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => node is ClassDeclarationSyntax || node is RecordDeclarationSyntax,
                transform: (ctx, _) => ctx.Node)
            .Where(n => n is ClassDeclarationSyntax || n is RecordDeclarationSyntax);

        var compilationAndTypes = context.CompilationProvider.Combine(typeDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndTypes, (spc, source) =>
        {
            var (compilation, typeNodes) = ((Compilation, System.Collections.Immutable.ImmutableArray<SyntaxNode>))source;
            var metas = new List<(string HandlerType, string EventType, List<string> CommandTypes)>();

            foreach (var typeDecl in typeNodes)
            {
                var semanticModel = compilation.GetSemanticModel(typeDecl.SyntaxTree);
                var symbol = semanticModel.GetDeclaredSymbol(typeDecl) as INamedTypeSymbol;
                if (symbol == null) continue;
                // 查找实现 IIntegrationEventHandler<TEvent> 的类型
                var handlerInterface = symbol.AllInterfaces.FirstOrDefault(i => i.Name == "IIntegrationEventHandler" && i.TypeArguments.Length == 1);
                if (handlerInterface != null)
                {
                    var eventType = handlerInterface.TypeArguments[0].ToDisplayString();
                    var commandTypes = new HashSet<string>();
                    // 1. 查找构造函数参数或字段/属性中是否有命令类型
                    foreach (var member in symbol.GetMembers())
                    {
                        if (member is IPropertySymbol prop && prop.Type is INamedTypeSymbol namedType && GeneratorExtensions.IsCommand(namedType))
                            commandTypes.Add(namedType.ToDisplayString());
                        if (member is IFieldSymbol field && field.Type is INamedTypeSymbol namedType2 && GeneratorExtensions.IsCommand(namedType2))
                            commandTypes.Add(namedType2.ToDisplayString());
                    }
                    // 2. 查找 HandleAsync 方法体中通过 _mediator.Send(new XxxCommand(...)) 发出的命令类型
                    foreach (var method in symbol.GetMembers().OfType<IMethodSymbol>())
                    {
                        foreach (var syntaxRef in method.DeclaringSyntaxReferences)
                        {
                            var methodSyntax = syntaxRef.GetSyntax() as MethodDeclarationSyntax;
                            if (methodSyntax != null)
                            {
                                foreach (var cmdType in methodSyntax.GetSentCommandTypes(semanticModel))
                                {
                                    commandTypes.Add(cmdType);
                                }
                            }
                        }
                    }
                    metas.Add((symbol.ToDisplayString(), eventType, commandTypes.ToList()));
                }
            }

            if (metas.Count > 0)
            {
                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated/>\nusing System;\nusing NetCorePal.Extensions.CodeAnalysis.Attributes;");
                foreach (var (handlerType, eventType, commandTypes) in metas)
                {
                    string commandsLiteral;
                    if (commandTypes.Count > 0)
                    {
                        commandsLiteral = "new string[] { " + string.Join(", ", commandTypes.Select(type => $"\"{type}\"")) + " }";
                    }
                    else
                    {
                        commandsLiteral = "new string[0]";
                    }
                    sb.AppendLine($"[assembly: IntegrationEventHandlerMetadataAttribute(\"{handlerType}\", \"{eventType}\", {commandsLiteral})]\n");
                }
                spc.AddSource("IntegrationEventHandlerMetadata.g.cs", sb.ToString());
            }
        });
    }
}
